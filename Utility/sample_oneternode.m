%% sample trees with only one terminal node: can only grow
function [T,Terstr,Rj] = sample_oneternode(T,Terstr,j,p,t,m,trainx,ytilta,mu,ntrain, pprune, pgrow, sigma2, dataind,sigmamu2,alpha,beta,bivar)
    % check if the terminal node is indexed as 1
    Tterminal = T(j).Terminal;
    if Tterminal ~= 1
        disp(['The only one terminal node is not indexed as 1'])
    end
    
    % can only grow on this terminal node, and the depth is 0;
    Ssplit = Tterminal;
    deta = 0;
    
    % uniformly select splitting varable
    probx = (1/p:1/p:1);
    k = find(probx>rand,1);
    
    % uniformly select splitting rule
    [~,ia,~]=unique(trainx(:,k)); neta = length(ia);
    probvalue = (1/neta:1/neta:1); e = find(probvalue > rand,1);
    splitvalue = trainx(ia(e),k);
    
    % Calculate the M-H ratio
    % 1. Calculate w2_star:number of internal nodes which have
    % only two children terminal nodes, after growth
    %Tterminalbefore = Tterminal; % store the Tterminal in last iteration in case the proposal is rejected
    newTterminal = [2*Ssplit, 2*Ssplit+1]; % new terminal nodes generated by the grow step
    Internal = Tterminal; % old terminal node become internal node
    Tterminal = Tterminal(Tterminal~=Ssplit); % delete the splitting node in the terminal node set
    Tterminal(end+1:end+length(newTterminal))=newTterminal; % add the new terminals
    Tterminal = sort(Tterminal);
    temp = Tterminal(rem(Tterminal,2)==0);
    w2_star = sum(ismember((temp)+1,Tterminal));
    
    % 2. Calculate Rj = ytilde - sum(not j) g
    Rj = computeRj(T, Terstr,m,mu,j,ytilta,ntrain);
    
    % which Rjs are in this selected splitting node? 
    % since we only have one terminal node, all the Rjs are in the selected
    % splitting node and the length is the length of the train data.
    Rl = Rj;
    nl = ntrain;
    
    % which Rjs are going to be in the left and right node
    % here we need to consider binary variables
     tmp = sort(unique(trainx(:,k)));
    if tmp==2
        tmp = sort(unique(trainx(:,k)));
        RLind = dataind(trainx(:,k) == tmp(1));
        RL = Rl(RLind);
        nL = length(RL);
        RRind = dataind(trainx(:,k) == tmp(2));
        RR = Rl(RRind);
        nR = length(RR);
    elseif splitvalue == max(trainx(:,k))
        RLind = dataind(trainx(:,k)<splitvalue);
        RL = Rj(RLind);
        nL = length(RL);
        RRind = dataind(trainx(:,k)==splitvalue);
        RR = Rj(RRind);
        nR = length(RR);
    else
        RLind = dataind(trainx(:,k)<=splitvalue);
        RL = Rl(RLind);
        nL = length(RL);
        RRind = dataind(trainx(:,k)>splitvalue);
        RR = Rl(RRind);
        nR = length(RR);
    end
    
    % 3. M-H ratio
    logA = log(pprune/pgrow)+log(t*p*neta)-log(w2_star);
    logB = (1/2)*(log(sigma2*(sigma2+nl*sigmamu2))-log((sigma2+nL*sigmamu2)*(sigma2+nR*sigmamu2)))+...
        sigmamu2/(2*sigma2)*((sum(RL))^2/(sigma2+nL*sigmamu2)+(sum(RR))^2/(sigma2+nR*sigmamu2)-(sum(Rl))^2/(sigma2+nl*sigmamu2));
    logC = log(alpha)+2*log(1-alpha/(2+deta)^beta)-log((1+deta)^beta-alpha)-log(p*neta);
    logr = logA+logB+logC;
    
    % Accept or not?
    ug1 = rand;
    if log(ug1) <= logr % Accept and grow on the selected splitting node with the splitting rule, renew the tree structure
        % T(j).Node = [T(j).Node, 2*Ssplit, 2*Ssplit+1]; % Store all the nodes in Tj
        T(j).Terminal = Tterminal; % store the index of terminal nodes
        T(j).Internal = Internal; % store the index of internal nodes
        T(j).spvar = k; % Store the split variable
        T(j).sprule =splitvalue; % Store the split rule
        Terstr(j).t2 = RLind;
        Terstr(j).t3 = RRind;
        fieldname = 't'+string(Internal);
        Terstr(j).(fieldname) = [];
    end
end
